const aStar = (unit,endHexLabel) => {
    let startHex = HexMap[unit.startHexLabel];
    let endHex = HexMap[endHexLabel];

    let move = unit.move;
    let distance = startHex.cube.distance(endHex.cube);

    let nodes = 1;
    let explored = [];
    let frontier = [{
        label: startHex.label,
        cost: 0,
        estimate: distance,
    }]

    while (frontier.length > 0) {
        //sort paths in frontier by cost,lowest cost first
        //choose lowest cost path from the frontier
        //if more than one, choose one with highest cost       
        frontier.sort(function(a,b) {
            return a.estimate - b.estimate || b.cost - a.cost; //2nd part used if estimates are same
        })
        let node = frontier.shift();
        let nodeHex = HexMap[node.label];
        nodes++;
        explored.push(node); //add this node to explored paths
        //if this node reaches goal, end loop
        if (node.label === endHexLabel) {
            break;
        }
        //generate possible next steps
        let next = HexMap[node.label].cube.neighbours();
        //for each possible next step
        for (let i=0;i<next.length;i++) {
            //calculate the cost of the next step 
            //by adding the step's cost to the node's cost
            let stepCube = next[i];
            let stepHexLabel = stepCube.label();
            let stepHex = HexMap[stepHexLabel];
            if (!stepHex) {continue};
            if (stepHex.offboard === true) {continue};
            let cost = stepHex.moveCosts[unit.moveType];
            //check if this step has already been explored
            let isExplored = (explored.find(e => {
                return e.label === stepHexLabel
            }));
            //avoid repeated nodes during the calcualtion of neighbours
            let isFrontier = (frontier.find(e => {
                return e.label === stepHexLabel
            }));
            //if this step has not been explored
            if (!isExplored && !isFrontier) {
                let est = cost + stepHex.cube.distance(endHex.cube);
                //add the step to the frontier
                frontier.push({
                    label: stepHexLabel,
                    cost: cost,
                    estimate: est,
                })
            }
        }
    }

    //if there are no paths left to explore or hit end hex
    let finalHexLabel = startHex.label;
    if (explored.length > 0) {
        array = [];
        results = [];
        explored.sort((a,b) => {
            return b.cost - a.cost;
        })
        let last = explored.shift();
        array.push(last);
        let finished = explored.length > 0 ? false:true;
        while (finished === false) {
            let lowestCost = last.cost;
            let current = 0;
            for (let i=0;i<explored.length;i++) {
                let next = explored[i];
                if (HexMap[next.label].cube.distance(HexMap[last.label].cube) === 1 && next.cost < lowestCost) {
                    lowestCost = next.cost;
                    current = i;
                }
            }
            last = explored[current];
            explored.splice(current,1);
            array.push(last);
            if (last.label === startHex.label) {
                finished = true;
            }
        }
        array.reverse();
        //will be an array from startHex to endHex, of lowest cost
        //now add up cumulative costs and stop if exceed move
        let cumulativeCost = 0;
        let finalSpot = array.length - 1;
        for (let i=1;i<array.length;i++) {
            cumulativeCost += array[i].cost;
            if (cumulativeCost > move) {
                finalSpot = i;
                break;
            }
        }
        finalHexLabel = array[finalSpot].label; 
    } else {
        sendChat(""," No Path to this Hex");
    }
    return finalHexLabel;
}